# Enabling the HSE Oscillator

## Overview

Most ARM Cortex-M boards will have an external crystal oscillator; they provide a more stable and precise clock signal, which is generally good and outright required by some higher-speed interfaces. The default "HSI" (I = Internal) oscillator will cycle at slightly - but noticeably - different frequencies as temperature, load, etc. varies. This example will target the same simple STM32F030 chip as before, but it will need a crystal (8 MHz in my case) on the board.

It will also place a full "vector table" at 0x0 to ensure a safe execution environment and common fault handling. A "vector table" is a special area of memory which tells the chip what code it should execute when a certain sort of hardware interrupt occurs. In our last example, we only filled out the bare minimum; entry #0 which defines how much RAM is available, and entry #1 which says where to start executing code after a reset. But each chip has a large number of hardware interrupts that can occur, and they will each look at a different vector table entry to figure out what memory address holds the code which will handle that interrupt. We do not suport most interrupts, so they will point to a default "handler" which does nothing. It may seem pointless to define so many unused interrupts, but if we ran the last 'hello_asm' example program and a random interrupt did get generated, the chip might try to look for its handler's address in an area we are using for code, which could have the program jump ANYWHERE. That is Undefined Behavior, and it is Bad. (Although, most interrupts do need to be explicitly enabled before they will trigger.)

This example also incorporates 'linker scripts' to allow easy configuration across multiple chips that are similar, but have different amounts of RAM and flash memory. They're pretty simple, but they are not easy to read. The gist is that they allocate a few common sections of memory like 'text' which contains read-only code, 'bss' which contains space that will be used by variables later but should start at 0, 'data' which contains pre-initialized data to be read from the nonvolatile flash memory, and a special 'isr_vector' which situates the vector table (see? It's important) at address 0. As a bonus, if we tell the linker how much space our chip has available, the linker can alert us with an error if our program is too big to fit on the chip. That was not a conern in the last program which was only 12 *bytes*, but you will be surprised at how quickly memory can disappear!

So in a nutshell, this project creates a stable environment for the chip, and then enables the HSE oscillator. First, it sets a complete vector table for the STM32F030 chip. Next, as a further safety feature, it runs some basic "reset" logic, initializing important segments of RAM and cleaning up some Read/Write registers which may not be automatically reset by the chip after a reset occurs. Finally, it enables the HSE oscillator, waits for it to be ready, and sets the system clock to its maximum 48MHz frequency using the 8MHz HSE oscillator and a PLL factor of 6.

Basically, it should be an example of a minimal program which makes and confirms a small change to the processor, and can reliably get into a happy state after unexpected resets. Embedded development has some 'gotchas' which can be very confusing and frustrating when you run into them headfirst, but if we obey some best practices (and refer heavily to our vendors' provided documentation), we can minimize the number of nasty surprises that we run into. Providing a complete vector table and ensuring that your system boots into a known state seem like a couple of good ones to start with. And happily, that is exactly the sort of thing that most vendors will stress in multiple technical documents and template files. An ounce of prevention is worth a pound of people calling into customer support, after all.

In these examples, the vendor is STMicroelectronics, and they provide a variety of datasheets, application notes, and a 'standard peripherals library' for many of their chips. The libraries are designed for C/C++, but they can be useful for double-checking things like memory addresses for important registers on the chip, if you're familiar with reading C header files. They also include 'startup' assembly files for booting the chip before sending it to execute the 'main' C function, which along with the datasheets, are good references for what values a particular chip expects in its vector table. Anyways, this is why I think raw assembly isn't a bad starting point; the "Hello, World" C programs all have a lot of hidden stuff going on that you have to ignore, and C is not a great language to teach programming anyways.

## New Code

You'll notice that there are separate vector table files now. In the folder called 'vector_tables'. They contain an entry for each of the interrupts generated by the peripheral hardware on the chip, but like I mentioned above, they probably shouldn't trigger unless you activate them first (which we'll go over later.) For this example, we'll simply ask the chip to do something, then wait for it to be ready with a loop. We *could* add a handler for the interrupt marked as 'RCC_IRQ_Handler' in this example to receive a hardware interrupt whenever a 'clock event' occurred. One type of 'clock event' is the HSE oscillator's signal stabilization, and we can check inside of the interrupt to see which exact event triggered it and act accordingly. But this is a tutorial which is not about hardware interrupts, and the chip does also set a bit in memory when the HSE oscillator stabilizes, so it's simpler for us to just wait for that bit to be set. And anyways, most C code would probably be along the lines of, 'while (!RCC->HSE_RDY) {NOP}' so what's the difference?

So, eschewing interrupts for now, enabling the HSE (High-Speed External) oscillator is as simple as setting a bit and waiting for the chip to set a different one. Then there are a couple of other bits used to select which clock source the system uses, and we can set those appropriately to select the HSE signal once it is stable. And then we can set the 'PLL' (Phase-Locked Loop) to drive the actual frequency of the core clock to a multiple of the system clock. I think we can think of the PLL as a fancy word for a number that we multiply the clock signal by; That's how we can reach the 'MHz' rating of the chip itself, which will be higher than the crystal oscillator's 8MHz. The STM32F030 which I am using can run at up to 48MHz, which means multiplying a 8MHz clock signal by 6. We could also use a 12MHz crystal with a factor of 4, or a 16MHz one with a factor of 3. Or we could choose a slower clock frequency to consume less power, produce less heat, etc.

Technically, it looks like the correct terminology is 'dividing the clock signal by 6' - not 'multiplying' - because a Hertz is (1 / a second), so 8MHz->48MHz means *reducing* the period of a sine/square wave. But I sort of feel like that kind of pedantry is what turns a lot of people off of this sort of hobby, so moving on...

Well, that's the gist of how to setup a stable high-speed system clock signal on these ARM Cortex-M chips. In the next example, we can use the precision of these clock signals to create a 'sleep' or 'delay' function which is accurate to the order of nanoseconds. That's one advantage of using a realtime embedded system; your laptop is constantly switching between tasks and splitting up its clock cycles between background and foreground tasks, so if you tried to measure time by your CPU's clock speed and the number of instructions executed, it would be wildly inaccurate. But with these simple assembly programs, we can get away with it! And once we can create precise delays, we can 'bit-bang' signals by precisely timing 1/0 signals on Input/Output pins to control things in the real world, like 'Neopixel' LEDs!

Please let me know if any of this is inaccurate - I'm just piecing things together from documentation, template code, seeing what works, and googling the error messages of what doesn't work.
