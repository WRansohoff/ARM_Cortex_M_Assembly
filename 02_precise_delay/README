# Creating precice delays

Embedded controllers are nice because we can very precisely estimate how much time it will take to do something. If there is any task or context switching, it will be something that we implemented (like a RealTime OS) and we can account for that. Otherwise, the only things capable of interrupting the program flow is a hardware interrupt, which were briefly discussed in the last example. With the vector table properly set up, a hardware interrupt will either be expected by the program, go to an infinite loop, or...well, okay, potentially make an ongoing timer invalid. But as our programs get more complex, there are other methods for handling applications which require very precise timing.

For now, we can just count instructions and use the knowledge of how long they take to execute. That duration is expressed in '# of clock cycles' for each type of instruction, but we know that the core system clock is (for example) 48MHz. When it comes to communicating with other chips, we will use signals that send 1's and 0's at a very fast rate, and a simple way to do that is to set a '1' or '0' on the pin, wait for however long the signal needs to last, and then un-set it. In the next example, we will communicate with a popular RGB LED chip that communicates using a sort of morse code for binary, where the '1/0's are represented by either 'dot/dash' or 'dash/dot'. For distinguishing between a 'dash'-length signal and a 'dot'-length signal at the timing it expects, we need some very precise delays.

So this tutorial will have two major parts of new code, and some restructuring. First, we will break the 'bootup' code from the last example into its own file - it will change a bit between different types of chips anyways. We'll also use separate Assembly 'functions' for common operations like 'read, OR with a value, store.' Those functions will go in a 'utilities' file, along with a new function for delaying a specified number of microseconds. Finally, we will enable a GPIO pin and use it to blink an LED on and off every half-second.

So I guess this is also a 'blink' example, which is a good 'hello world' for microprocessors. But the previous two examples will explain some startup/initialization stuff which this example glosses over.
